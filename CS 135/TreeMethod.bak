#lang racket
;; Tree Method Program [INCOMPLETE]
;; By: Christian Bautista
;;
;; Restrictions: Conclusion cannot be compound
;; Propositional Methods: reversers, conditional, biconditional, de Morgan
(define (reverser-string S)
  (if (string=? (substring S 0 1) "!") (substring S 1) (string-append "!" S)))
(define (reverser-list L)
  (if (string? (car L)) (if (string=? (car L) "!") (cadr L) (list "!" L)) (list "!" L)))
(define (reverser-andor X)
  (if (string=? X "&&") "||" "&&"))
(define (deMorgan P)
  (cond ((and (string? (car P)) (string? (caddr P))) (list (reverser-string (car P)) (reverser-andor (cadr P)) (reverser-string (caddr P))))
        ((and (list? (car P)) (string? (caddr P))) (list (reverser-list (car P)) (reverser-andor (cadr P)) (reverser-string (caddr P))))
        ((and (string? (car P)) (list? (caddr P))) (list (reverser-string (car P)) (reverser-andor (cadr P)) (reverser-list (caddr P))))
        (else (list (reverser-list (car P)) (reverser-andor (cadr P)) (reverser-list (caddr P))))))
(define (conditional P)
  (if (list? (car P)) (list (reverser-list (car P)) "||" (caddr P)) (list (reverser-string (car P)) "||" (caddr P))))
(define (biconditional P)
  (list (conditional (list (car P) "=>" (caddr P))) "&&" (conditional (list (caddr P) "=>" (car P)))))
;; Tree Methods: neg-con, add (to branch or to stack), contradictacator (check with stack),
(define paths null)
(define contras null)
(define con-holder null)
(define con-loop-holder null)
(struct node (data left right) #:transparent #:mutable)
(define (add-to-root T L)
  (cond ((null? T) (if (list? L)
                       (cond ((eq? (length L) 3)
                              (cond ((and (string? (car L)) (string? (caddr L))) (if (string=? (cadr L) "||") (node '() (car L) (caddr L)) (node (list (car L) (caddr L)) null null)))
                                    ((and (list? (car L)) (string? (caddr L))) (if (string=? (cadr L) "||")
                                                                                   (node '() (simplifier-helper (car L)) (node (caddr L) null null))
                                                                                   (add-statement (node (list (caddr L)) null null) (simplifier-helper (car L)))))
                                    ((and (string? (car L)) (list? (caddr L))) (if (string=? (cadr L) "||")
                                                                                   (node '() (node (car L) null null) (simplifier-helper (caddr L)))
                                                                                   (add-statement (node (list (car L)) null null) (simplifier-helper (caddr L)))))
                                    (else (if (string=? (cadr L) "||")
                                              (node '() (simplifier-helper (car L)) (simplifier-helper (caddr L)))
                                              (add-statement (add-statement T (simplifier-helper (car L))) (simplifier-helper (caddr L)))))))
                             ((eq? (length L) 2) (add-to-root T (simplifier-helper L)))
                             (else (node L null null)))
                       (node (list L) null null)))
        ((list? L) (cond ((eq? (length L) 3) (cond ((and (string? (car L)) (string? (caddr L))) (begin (set-node-data! T (append (node-data T) (list (car L) (caddr L)))) T))
                                                   ((and (list? (car L)) (string? (caddr L))) (begin (add-statement (set-node-data! T (append (node-data T) (caddr L))) (car L)) T))
                                                   ((and (string? (car L)) (list? (caddr L))) (begin (add-statement (set-node-data! T (append (node-data T) (car L))) (caddr L)) T))
                                                   (else (begin (add-statement T (car L)) (add-statement T (caddr L)) T))))
                         ((eq? (length L) 2) (add-statement T (simplifier-helper L)))
                         (else (begin (set-node-data! T (append (node-data T) L)) T))))
        (else (begin (set-node-data! T (append (node-data T) (list L))) T))))
;;May have to change (append (node-data T) L) -> (set-node-data! T (append (node-data T) L))
(define (leaf? N)
  (if (and (null? (node-left N)) (null? (node-right N))) #t #f))
(define (contra? N)
  (if (and (string? (node-left N)) (string? (node-right N))) (if (and (string=? "CONTRA" (node-left N)) (string=? "CONTRA" (node-right N))) #t #f) #f))
;;(if (and (null? (node-left N)) (null? (node-right N))) #t #f))
;;Fix below to incorporate various cases: 4 cases of L: Both string, left list, right list, both lists, tree errors possibly?
(define (add-leaves T L)
  (if (not (contra? T))
      (if (leaf? T) (begin
                      (set-node-left! T (node (car L) null null))
                      (set-node-right! T (node (cadr L) null null))
                      T)
          (begin
            (add-leaves (node-left T) L)
            (add-leaves (node-right T) L)))
      T))
(define (find T P)
  (if (null? P) T (if (list? (car P))
                      (if (string? (node-data T))
                          (cond ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (list? (node-data (node-right T))))
                                 (if (equal? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR")))
                          (cond ((equal? (car P) (node-data T)) T)
                                ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (list? (node-data (node-right T))))
                                 (if (equal? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR"))))
                      (if (list? (node-data T))
                          (cond ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (string? (node-data (node-right T))))
                                 (if (string=? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR")))
                          (cond ((string=? (car P) (node-data T)) T)
                                ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (string? (node-data (node-right T))))
                                 (if (string=? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR")))))))
(define (find-paths-helper N P)
  (if (null? N) '() (begin
                      (set! P (append P (list (node-data N))))
                      (if (or (leaf? N) (contra? N)) (set! paths (append paths (list P))) (begin
                                                                                            (find-paths-helper (node-left N) P)
                                                                                            (find-paths-helper (node-right N) P))))))
(define (find-paths T)
  (if (null? T) '() (begin
                      (set! paths '())
                      (find-paths-helper T '())
                      paths)))
;;P is all paths of the tree
(define (list-leaves-finder P)
  (cond ((null? P) '())
        ((list? (car (reverse (car P)))) (append (list (car P)) (list-leaves-finder (cdr P))))
        (else (list-leaves-finder (cdr P)))))
(define (leaf-list-breaker T N)
  (if (eq? (length (node-data N)) 3) (cond ((string=? (cadr (node-data N)) "||") (begin (set-node-left! N (car (node-data N))) (set-node-right! N (caddr (node-data N))) T))
                                           ((string=? (cadr (node-data N)) "&&") (begin (add-statement (add-statement T (car (node-data N))) (caddr (node-data N))) T))
                                           (else (begin (set-node-data! N (simplifier-helper (node-data N))) (leaf-list-breaker T N))))
      (begin (set-node-data! N (simplifier-helper (node-data N))) (leaf-list-breaker N))))
;;P is (list-leaves-finder (find-paths T))
(define (list-leaves-breaker T P)
  (if (null? P) T (list-leaves-breaker (leaf-list-breaker T (find T (cdar P))) (cdr P))))
;;if contradictacator returns a list, translate it, else, do something
;;#f = no contradictions; #t = there are contradictions
;;#t = new contra; #false = existing contra
(define (filter-contras-helper C P)
  (cond ((null? C) #t)
        ((equal? (car C) P) #f)
        (else (filter-contras-helper (cdr C) P))))
(define (filter-contras P N)
  (cond ((null? P) N)
        ((filter-contras-helper contras (car P)) (filter-contras (cdr P) (append N (list (car P)))))
        (else (filter-contras (cdr P) N))))
(define (contradictacator-root R)
  (cond ((null? R) #f)
        ((eq? (length R) 1) #f)
        ((contradictacator-single (cdr R) (car R)) #t)
        (else (contradictacator-root (cdr R)))))
(define (contradictacator-single L E)
  (cond ((null? L) #f)
        ((string=? E (car L)) #f)
        ((string=? (substring E 0 1) "!") (if (string=? (car L) (substring E 1)) #t (contradictacator-single (cdr L) E)))
        ((string=? (substring (car L) 0 1) "!") (if (string=? (substring (car L) 1) E) #t (contradictacator-single (cdr L) E)))
        (else (contradictacator-single (cdr L) E))))
(define (contradictacator-path L P)
  (cond ((null? P) #f)
        ((string? (car P)) (if (contradictacator-single L (car P)) #t (contradictacator-path L (cdr P))))
        (else (contradictacator-path L (cdr P)))))
(define (contradictacator-helper P C)
  (cond ((null? P) C)
        ((contradictacator-path (caar P) (cdar P)) (contradictacator-helper (cdr P) (append C (list (car P)))))
        (else (contradictacator-helper (cdr P) C))))
(define (contradictacator P)
  (begin (set! con-holder (contradictacator-helper P '()))
         (if (null? (filter-contras con-holder '())) #f
             (begin (set! contras (append contras (filter-contras con-holder '()))) con-holder ))))
;;Contradictacator returns new contras 
;;Check if list length is 3 (normal proposition) or 2 (negated proposition)
;;Next, check biconds, conds, then deMorgans
(define (simplifier-helper P)
  (cond ((string? P) P)
        ((eq? (length P) 3)
         (cond ((string=? (cadr P) "<=>") (biconditional P))
               ((string=? (cadr P) "=>") (conditional P))
               (else P)))
         ((eq? (length P) 2)
          (cond ((eq? (length (cadr P)) 3) (if (or (string=? (cadadr P) "&&") (string=? (cadadr P) "||")) (deMorgan (cadr P)) (simplifier-helper (list "!" (simplifier-helper (cadr P))))))
                ((eq? (length (cadr P)) 2) (simplifier-helper (cadadr P)))
                (else P)))
         (else P)))
(define (simplifier P N)
  (cond ((null? P) N)
        ((string? (simplifier-helper (car P))) (simplifier (cdr P) (append N (list (list (simplifier-helper (car P)))))))
        ((eq? (length (simplifier-helper (car P))) 3)
         (if (or (list? (car (simplifier-helper (car P)))) (list? (caddr (simplifier-helper (car P)))))
             (if (string=? (cadr (simplifier-helper (car P))) "&&")
                 (simplifier (cdr P) (append N (append (list (car (simplifier-helper (car P)))) (list (caddr (simplifier-helper (car P)))))))
                 (simplifier (cdr P) (append N (list (simplifier-helper (car P))))))
             (simplifier (cdr P) (append N (list (simplifier-helper (car P)))))))
        (else (simplifier (cdr P) (append N (list (simplifier-helper (car P))))))))
;;Root INCLUDES and, Leaf DOES NOT include or.
(define (add-statement T P)
  (cond ((string? P) (add-to-root T P))
        ((eq? (length P) 3) (cond ((string=? (cadr P) "&&") (add-to-root T P))
                                  ((string=? (cadr P) "||") (add-leaves T (list (car P) (caddr P))))
                                  (else (add-statement T (simplifier-helper P)))))
        ((eq? (length P) 2) (add-statement T (simplifier-helper P)))
        (else (add-to-root T P))))
(define (contradictacator-filler T P)
  (if (null? P) T (begin (set-node-left! (find T (cdar P)) "CONTRA") (set-node-right! (find T (cdar P)) "CONTRA") (contradictacator-filler T (cdr P)))))
(define (list-leaves-looper T P)
  (if (null? (list-leaves-finder P)) T
      (list-leaves-looper (list-leaves-breaker T (list-leaves-finder P)) (find-paths (list-leaves-breaker T (list-leaves-finder P))))))
(define (contradictacator-looper T P)
  (begin (set! con-loop-holder (contradictacator P))
         (if (boolean? con-loop-holder) T
             (contradictacator-looper (contradictacator-filler T con-loop-holder) (filter-contras (find-paths (contradictacator-filler T con-loop-holder)) '())))))
(define (simplifier-looper P)
  (if (equal? (simplifier P '()) (simplifier (simplifier P '()) '())) (simplifier P '()) (simplifier-looper (simplifier P '()))))
;;Possibly change the (if (contradictacator-root (node-data T)) T line
;;#t = tautology; #f = counterexample
(define (tautology?-helper P C)
  (cond ((and (null? P) (null? C)) #t)
        ((boolean? (member (car P) C)) #f)
        (else (tautology?-helper (cdr P) (remove (car P) C)))))
(define (tautology? P C)
  (if (not (eq? (length P) (length C))) #f (tautology?-helper P C)))
;;Possibly delete (set! tree '()) in here, also possibly find a way to omit tree?
;;Return #t/#f and tree
(define (tree-method-helper T P)
  (if (null? P) (list #f T) (begin (add-statement T (car P))
                                   (display T)
                                   (set! T (list-leaves-looper T (find-paths T)))
                                   (if (contradictacator-root (node-data T)) (list #t T)
                                       (begin (set! T (contradictacator-looper T (find-paths T)))
                                              (if (tautology? (find-paths T) contras) (list #t T) (tree-method-helper T (cdr P))))))))
(define (tree-method P C)
  (begin (set! P (simplifier-looper P))
         (tree-method-helper (add-to-root '() (car (simplifier-looper (list (list "!" C))))) P)))

(define props null)
(define conc null)
(define tree null)
(define ch null)
(define (test)
  (begin (set! props (simplifier-looper '(("B" "=>" "I") ("M" "=>" "!D") ("I" "=>" "D"))))
         (set! conc (car (simplifier-looper (list (list "!" '("B" "=>" "!M"))))))
         (set! tree (add-to-root '() conc))
         (set! tree (add-statement tree (car props)))
         (set! tree (list-leaves-looper tree (find-paths tree)))
         (contradictacator-root (node-data tree))))
(define tr null)
(define (test2)
  (begin (set! tr (node '("B" "M") (node "!B" "CONTRA" "CONTRA") (node "I" null null)))
         (add-statement tr '("B" "||" "I"))
         tr))
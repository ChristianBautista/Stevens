#lang racket
;; Tree Method Program [INCOMPLETE]
;; By: Christian Bautista
;; I pledge my honor that I have abided by the Stevens Honor System.
;;
;; Valid Logic Symbols: "!", "&&", "||", "=>" "<=>"
;; Input: (tree-method (list of propositions) (conclusion))
;; Valid Propositions:
;; - ("A" "&&" "B")
;; - ("A" "||" "B")
;; - ("A" "=>" "B")
;; - ("A" "<=>" "B")
;; - ("!" ("A" "&&" "B"))
;; Output: '(#t/#f tree)
;; Restrictions:
;; - Each "proposition" must have a max length of 3 and min length of 1
;; - Conclusion cannot be compound
;; - There are some hidden bugs (usually with compound inputs or super simple inputs)
;; Propositional Methods: reversers, conditional, biconditional, de Morgan
(define (reverser-string S)
  (if (string=? (substring S 0 1) "!") (substring S 1) (string-append "!" S)))
(define (reverser-list L)
  (if (string? (car L)) (if (string=? (car L) "!") (cadr L) (list "!" L)) (list "!" L)))
(define (reverser-andor X)
  (if (string=? X "&&") "||" "&&"))
(define (deMorgan P)
  (cond ((and (string? (car P)) (string? (caddr P))) (list (reverser-string (car P)) (reverser-andor (cadr P)) (reverser-string (caddr P))))
        ((and (list? (car P)) (string? (caddr P))) (list (reverser-list (car P)) (reverser-andor (cadr P)) (reverser-string (caddr P))))
        ((and (string? (car P)) (list? (caddr P))) (list (reverser-string (car P)) (reverser-andor (cadr P)) (reverser-list (caddr P))))
        (else (list (reverser-list (car P)) (reverser-andor (cadr P)) (reverser-list (caddr P))))))
(define (conditional P)
  (if (list? (car P)) (list (reverser-list (car P)) "||" (caddr P)) (list (reverser-string (car P)) "||" (caddr P))))
(define (biconditional P)
  (list (conditional (list (car P) "=>" (caddr P))) "&&" (conditional (list (caddr P) "=>" (car P)))))
;; Tree Methods: add-to-root/add-leaves, find-paths, list-leaves-breaker, contradictacator, etc.
(define paths null)
(define contras null)
(define con-holder null)
(define con-loop-holder null)
(define list-leaves null)
(define result null)
(struct node (data left right) #:transparent #:mutable)
(define (add-to-root T L)
  (cond ((null? T) (if (list? L)
                       (cond ((eq? (length L) 3)
                              (cond ((and (string? (car L)) (string? (caddr L))) (if (string=? (cadr L) "||") (node '() (node (car L) null null) (node (caddr L) null null))
                                                                                     (node (list (car L) (caddr L)) null null)))
                                    ((and (list? (car L)) (string? (caddr L))) (if (string=? (cadr L) "||")
                                                                                   (node '() (simplifier-helper (car L)) (node (caddr L) null null))
                                                                                   (add-statement (node (list (caddr L)) null null) (simplifier-helper (car L)))))
                                    ((and (string? (car L)) (list? (caddr L))) (if (string=? (cadr L) "||")
                                                                                   (node '() (node (car L) null null) (simplifier-helper (caddr L)))
                                                                                   (add-statement (node (list (car L)) null null) (simplifier-helper (caddr L)))))
                                    (else (if (string=? (cadr L) "||")
                                              (node '() (simplifier-helper (car L)) (simplifier-helper (caddr L)))
                                              (add-statement (add-statement T (simplifier-helper (car L))) (simplifier-helper (caddr L)))))))
                             ((eq? (length L) 2) (add-to-root T (simplifier-helper L)))
                             (else (node L null null)))
                       (node (list L) null null)))
        ((list? L) (cond ((eq? (length L) 3) (cond ((and (string? (car L)) (string? (caddr L))) (begin (set-node-data! T (append (node-data T) (list (car L) (caddr L)))) T))
                                                   ((and (list? (car L)) (string? (caddr L))) (begin (add-statement (set-node-data! T (append (node-data T) (caddr L))) (car L)) T))
                                                   ((and (string? (car L)) (list? (caddr L))) (begin (add-statement (set-node-data! T (append (node-data T) (car L))) (caddr L)) T))
                                                   (else (begin (add-statement T (car L)) (add-statement T (caddr L)) T))))
                         ((eq? (length L) 2) (add-statement T (simplifier-helper L)))
                         (else (begin (set-node-data! T (append (node-data T) L)) T))))
        (else (begin (set-node-data! T (append (node-data T) (list L))) T))))
;;May have to change (append (node-data T) L) -> (set-node-data! T (append (node-data T) L))
(define (leaf? N)
  (if (and (null? (node-left N)) (null? (node-right N))) #t #f))
(define (contra? N)
  (if (and (string? (node-left N)) (string? (node-right N))) (if (and (string=? "CONTRA" (node-left N)) (string=? "CONTRA" (node-right N))) #t #f) #f))
;;(if (and (null? (node-left N)) (null? (node-right N))) #t #f))
;;Fix below to incorporate various cases: 4 cases of L: Both string, left list, right list, both lists, tree errors possibly?
(define (add-leaves T L)
  (if (not (contra? T))
      (if (leaf? T) (begin
                      (set-node-left! T (node (car L) null null))
                      (set-node-right! T (node (cadr L) null null))
                      T)
          (begin
            (add-leaves (node-left T) L)
            (add-leaves (node-right T) L)))
      T))
(define (find T P)
  (if (null? P) T (if (list? (car P))
                      (if (string? (node-data T))
                          (cond ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (list? (node-data (node-right T))))
                                 (if (equal? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR")))
                          (cond ((equal? (car P) (node-data T)) T)
                                ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (list? (node-data (node-left T))) (list? (node-data (node-right T))))
                                 (if (equal? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR"))))
                      (if (list? (node-data T))
                          (cond ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (string? (node-data (node-right T))))
                                 (if (string=? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR")))
                          (cond ((string=? (car P) (node-data T)) T)
                                ((and (list? (node-data (node-left T))) (string? (node-data (node-right T)))) (find (node-right T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (list? (node-data (node-right T)))) (find (node-left T) (cdr P)))
                                ((and (string? (node-data (node-left T))) (string? (node-data (node-right T))))
                                 (if (string=? (car P) (node-data (node-left T))) (find (node-left T) (cdr P)) (find (node-right T) (cdr P))))
                                (else (display "ERROR")))))))
(define (find-paths-helper N P)
  (if (null? N) '() (begin
                      (set! P (append P (list (node-data N))))
                      (if (or (leaf? N) (contra? N)) (set! paths (append paths (list P))) (begin
                                                                                            (find-paths-helper (node-left N) P)
                                                                                            (find-paths-helper (node-right N) P))))))
(define (find-paths T)
  (if (null? T) '() (begin
                      (set! paths '())
                      (find-paths-helper T '())
                      paths)))
;;P is all paths of the tree
(define (list-leaves-finder P)
  (cond ((null? P) '())
        ((list? (car (reverse (car P)))) (if (list? (member (cdar P) list-leaves)) (list-leaves-finder (cdr P))
                                             (begin (set! list-leaves (append list-leaves (list (cdar P))))
                                                    (append (list (car P)) (list-leaves-finder (cdr P))))))
        (else (list-leaves-finder (cdr P)))))
(define (leaf-list-breaker T N)
  (if (eq? (length (node-data N)) 3) (cond ((string=? (cadr (node-data N)) "||") (begin (set-node-left! N (node (car (node-data N)) null null))
                                                                                        (set-node-right! N (node (caddr (node-data N)) null null))
                                                                                        T))
                                           ((string=? (cadr (node-data N)) "&&") (begin (add-statement (add-statement T (car (node-data N))) (caddr (node-data N))) T))
                                           (else (begin (set-node-data! N (simplifier-helper (node-data N))) (leaf-list-breaker T N))))
      (begin (set-node-data! N (simplifier-helper (node-data N))) (leaf-list-breaker N))))
;;P is (list-leaves-finder (find-paths T))
(define (list-leaves-breaker T P)
  (if (null? P) T (list-leaves-breaker (leaf-list-breaker T (find T (cdar P))) (cdr P))))
;;if contradictacator returns a list, translate it, else, do something
;;#f = no contradictions; #t = there are contradictions
;;#t = new contra; #false = existing contra
(define (filter-contras-helper C P)
  (cond ((null? C) #t)
        ((equal? (car C) P) #f)
        (else (filter-contras-helper (cdr C) P))))
(define (filter-contras P N)
  (cond ((null? P) N)
        ((filter-contras-helper contras (car P)) (filter-contras (cdr P) (append N (list (car P)))))
        (else (filter-contras (cdr P) N))))
(define (contradictacator-root R)
  (cond ((null? R) #f)
        ((eq? (length R) 1) #f)
        ((contradictacator-single (cdr R) (car R)) #t)
        (else (contradictacator-root (cdr R)))))
(define (contradictacator-single L E)
  (cond ((null? L) #f)
        ((list? (car L)) (contradictacator-single (cdr L) E))
        ((string=? E (car L)) #f)
        ((string=? (substring E 0 1) "!") (if (string=? (car L) (substring E 1)) #t (contradictacator-single (cdr L) E)))
        ((string=? (substring (car L) 0 1) "!") (if (string=? (substring (car L) 1) E) #t (contradictacator-single (cdr L) E)))
        (else (contradictacator-single (cdr L) E))))
(define (contradictacator-path L P)
  (cond ((null? P) #f)
        ((string? (car P)) (if (contradictacator-single L (car P)) #t (contradictacator-path L (cdr P))))
        (else (contradictacator-path L (cdr P)))))
(define (contradictacator-branch P)
  (cond ((null? P) #f)
        ((string? (car P)) (if (contradictacator-single (cdr P) (car P)) #t (contradictacator-branch (cdr P))))
        (else (contradictacator-branch (cdr P)))))
(define (contradictacator-helper P C)
  (cond ((null? P) C)
        ((or (contradictacator-path (caar P) (cdar P)) (contradictacator-branch (cdar P))) (contradictacator-helper (cdr P) (append C (list (car P)))))
        (else (contradictacator-helper (cdr P) C))))
(define (contradictacator P)
  (begin (set! con-holder (remove-duplicates (contradictacator-helper P '())))
         (if (null? (filter-contras con-holder '())) #f
             (begin (set! contras (append contras (filter-contras con-holder '()))) con-holder ))))
;;Contradictacator returns new contras 
;;Check if list length is 3 (normal proposition) or 2 (negated proposition)
;;Next, check biconds, conds, then deMorgans
(define (simplifier-helper P)
  (cond ((string? P) P)
        ((eq? (length P) 3)
         (cond ((string=? (cadr P) "<=>") (biconditional P))
               ((string=? (cadr P) "=>") (conditional P))
               (else P)))
         ((eq? (length P) 2)
          (cond ((eq? (length (cadr P)) 3) (if (or (string=? (cadadr P) "&&") (string=? (cadadr P) "||")) (deMorgan (cadr P)) (simplifier-helper (list "!" (simplifier-helper (cadr P))))))
                ((eq? (length (cadr P)) 2) (simplifier-helper (cadadr P)))
                (else (if (string=? (substring (caadr P) 0 1) "!") (list (substring (caadr P) 1)) (list (string-append "!" (caadr P)))))))
         (else P)))
(define (simplifier P N)
  (cond ((null? P) N)
        ((string? (simplifier-helper (car P))) (simplifier (cdr P) (append N (list (list (simplifier-helper (car P)))))))
        ((eq? (length (simplifier-helper (car P))) 3)
         (if (or (list? (car (simplifier-helper (car P)))) (list? (caddr (simplifier-helper (car P)))))
             (if (string=? (cadr (simplifier-helper (car P))) "&&")
                 (simplifier (cdr P) (append N (append (list (car (simplifier-helper (car P)))) (list (caddr (simplifier-helper (car P)))))))
                 (simplifier (cdr P) (append N (list (simplifier-helper (car P))))))
             (simplifier (cdr P) (append N (list (simplifier-helper (car P)))))))
        (else (simplifier (cdr P) (append N (list (simplifier-helper (car P))))))))
;;Root INCLUDES and, Leaf DOES NOT include or.
(define (add-statement T P)
  (cond ((string? P) (add-to-root T P))
        ((eq? (length P) 3) (cond ((string=? (cadr P) "&&") (add-to-root T P))
                                  ((string=? (cadr P) "||") (add-leaves T (list (car P) (caddr P))))
                                  (else (add-statement T (simplifier-helper P)))))
        ((eq? (length P) 2) (add-statement T (simplifier-helper P)))
        (else (add-to-root T P))))
(define (contradictacator-filler T P)
  (if (null? P) T (begin (set-node-left! (find T (cdar P)) "CONTRA") (set-node-right! (find T (cdar P)) "CONTRA") (contradictacator-filler T (cdr P)))))
(define (list-leaves-looper T P)
  (begin (set! P (list-leaves-finder P))
         (if (null? P) T
             (begin (set! T (list-leaves-breaker T P))
                    (list-leaves-looper T (find-paths T))))))
(define (contradictacator-looper T P)
  (begin (set! con-loop-holder (contradictacator P))
         (if (boolean? con-loop-holder) T
             (contradictacator-looper (contradictacator-filler T con-loop-holder) (filter-contras (find-paths (contradictacator-filler T con-loop-holder)) '())))))
(define (simplifier-looper P)
  (if (equal? (simplifier P '()) (simplifier (simplifier P '()) '())) (simplifier P '()) (simplifier-looper (simplifier P '()))))
;;#t = tautology; #f = counterexample
(define (tautology? T P)
  (cond ((null? P) #t)
        ((contra? (find T (cdar P))) (tautology? T (cdr P)))
        (else #f)))
;;Return #t/#f and tree
(define (tree-method-helper T P)
  (if (null? P) (list #f T) (begin (add-statement T (car P))
                                   (set-node-data! T (remove-duplicates (node-data T)))
                                   (set! T (if (eq? (length (find-paths T)) 1) T (list-leaves-looper T (find-paths T))))
                                   (if (contradictacator-root (node-data T)) (list #t T)
                                       (begin (set! T (contradictacator-looper T (find-paths T)))
                                              (if (tautology? T (find-paths T)) (list #t T) (tree-method-helper T (cdr P))))))))
(define (tree-method P C)
  (begin (set! P (simplifier-looper P))
         (set! contras null)
         (set! list-leaves null)
         (set! result (tree-method-helper (add-to-root '() (car (simplifier-looper (list (list "!" C))))) P))
         (if (car result) (list "Tautology" (cadr result))
             (list (filter-contras (find-paths (cadr result)) '()) (cadr result))))) 

;; (tree-method '(("ON" "&&" "OFF")) '("ON")) -> #t
;; (tree-method '(("ON" "||" "OFF")) '("ON")) -> #f
;; (tree-method '(("ON" "=>" "OFF")) '("ON")) -> #f
;; (tree-method '(("ON" "<=>" "OFF")) '("ON")) -> #f
;; (tree-method '(("B" "=>" "I") ("M" "=>" "!D") ("I" "=>" "D")) '("B" "=>" "!M")) -> #t
;; (tree-method '(("A" "||" ("B" "&&" "C")) ("A" "=>" "C")) '("!" ("C" "&&" "B"))) -> #f
;; (tree-method  '(("P" "=>" ("K" "=>" ("!Z" "=>" "!B"))) ("N" "=>" ("X" "=>" "K")) ("E" "=>" "O") ("E" "=>" "N") ("E" "=>" "B") ("!P" "=>" "!O")  ("Z" "=>" "!X") ("X"))  '("!E")) -> #t